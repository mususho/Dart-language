# استخدام Set في Sliding Window لتحقق uniqueness

## ✅ أولًا: ما الهدف من هذه الخوارزمية؟

نريد التحقق مما إذا كان هناك **نافذة (window)** بطول معين `k` داخل قائمة (أو سلسلة)، تحتوي على **عناصر فريدة فقط**.

---

### 🎯 مثال:

```dart
dart
CopyEdit
List<int> nums = [1, 2, 3, 1, 4, 5];
int k = 3;

```

نريد أن نجد نافذة بطول 3 بحيث لا تتكرر أي قيمة داخلها.

النتيجة: ✅ موجودة (مثلاً [2, 3, 1]، أو [1, 4, 5]).

---

## 🧠 لماذا نستخدم Set؟

لأن الـ `Set` لا يسمح بتكرار العناصر، ويساعدنا في التحقق بسرعة إذا كانت العناصر في النافذة فريدة أو لا.

---

## ✳️ خطوات بناء الخوارزمية:

1. إنشاء Set لتتبع العناصر داخل النافذة.
2. استخدام حلقة (Sliding Window) تمر عبر القائمة بمرونة:
    - نُضيف العنصر الحالي.
    - نتحقق إن كان موجودًا مسبقًا → يعني تكرار → النافذة غير فريدة.
    - نحافظ على حجم النافذة = k عن طريق إزالة العنصر الذي خرج.
3. نكرر حتى نهاية القائمة.
4. إذا وجدنا نافذة فيها كل العناصر فريدة → نعيد `true`، وإلا `false`.

---

## 🧾 الكود الكامل بلغة Dart مشروح خطوة بخطوة:

```dart
dart
CopyEdit
// الخطوة 1: تعريف دالة تتحقق هل توجد نافذة بطول k تحتوي على عناصر فريدة
bool hasUniqueWindow(List<int> nums, int k) {
  // الخطوة 2: التحقق المبدئي — إذا كانت القائمة أصغر من k فلا يمكن وجود نافذة
  if (nums.length < k) return false;

  // الخطوة 3: Set لحفظ العناصر داخل النافذة الحالية
  Set<int> windowSet = {};

  // الخطوة 4: استخدام نافذة متحركة (sliding window)
  int left = 0; // مؤشر بداية النافذة

  for (int right = 0; right < nums.length; right++) {
    // نحرك النهاية ونضيف العنصر الحالي
    int current = nums[right];

    // إذا العنصر موجود مسبقًا داخل النافذة → التكرار موجود
    while (windowSet.contains(current)) {
      // نزيل العنصر الموجود من البداية حتى يختفي التكرار
      windowSet.remove(nums[left]);
      left++;
    }

    // أضف العنصر الحالي بعد إزالة التكرارات
    windowSet.add(current);

    // تحقق: إذا أصبحت النافذة بطول k وبلا تكرار → أوقف وأرجع true
    if (windowSet.length == k) {
      return true;
    }
  }

  // إذا لم نجد أي نافذة فريدة بطول k → أرجع false
  return false;
}

// الخطوة 5: تجربة الخوارزمية
void main() {
  // مثال 1: توجد نافذة فريدة بطول 3
  List<int> list1 = [1, 2, 3, 1, 4, 5];
  int k1 = 3;
  print("هل توجد نافذة فريدة بطول $k1 في list1؟ ${hasUniqueWindow(list1, k1)}"); // ✅ true

  // مثال 2: لا توجد نافذة فريدة بطول 4 (بسبب التكرارات)
  List<int> list2 = [1, 1, 1, 1];
  int k2 = 2;
  print("هل توجد نافذة فريدة بطول $k2 في list2؟ ${hasUniqueWindow(list2, k2)}"); // ❌ false

  // مثال 3: نافذة فريدة بطول 5 في النهاية
  List<int> list3 = [1, 2, 2, 3, 4, 5];
  int k3 = 4;
  print("هل توجد نافذة فريدة بطول $k3 في list3؟ ${hasUniqueWindow(list3, k3)}"); // ✅ true

  // مثال 4: القائمة أقصر من k
  List<int> list4 = [1, 2];
  int k4 = 3;
  print("هل توجد نافذة فريدة بطول $k4 في list4؟ ${hasUniqueWindow(list4, k4)}"); // ❌ false

  // مثال 5: كل العناصر فريدة من البداية
  List<int> list5 = [5, 6, 7, 8, 9];
  int k5 = 5;
  print("هل توجد نافذة فريدة بطول $k5 في list5؟ ${hasUniqueWindow(list5, k5)}"); // ✅ true
}

```

---

## 🧪 الإخراج المتوقع:

```
arduino
CopyEdit
هل توجد نافذة فريدة بطول 3 في list1؟ true
هل توجد نافذة فريدة بطول 2 في list2؟ false
هل توجد نافذة فريدة بطول 4 في list3؟ true
هل توجد نافذة فريدة بطول 3 في list4؟ false
هل توجد نافذة فريدة بطول 5 في list5؟ true

```

---

## 📌 ملاحظات تقنية:

| المبدأ | لماذا؟ |
| --- | --- |
| `Set` | للكشف السريع عن التكرار بدون الحاجة لمسح كل العناصر |
| `while` لإزالة التكرارات | للحفاظ على فريدة العناصر داخل النافذة |
| Sliding Window | لتقليل التعقيد من `O(n*k)` إلى `O(n)` |

---

## 🎯 تطبيقات عملية:

- كشف التسلسل الفريد ضمن بيانات الشبكة أو الاستشعار
- تحليل النصوص للكشف عن substrings فريدة
- أنظمة مراقبة البيانات لتجنب التكرار

---

## ✅ الخلاصة:

- خوارزمية **Sliding Window + Set** تمنحنا أداءً عاليًا لتحقق من الفريدة داخل نافذة محددة.
- تنفذ خلال وقت `O(n)` فقط، وتستهلك مساحة `O(k)` فقط.
- مناسبة جدًا لتحليل البيانات الكبيرة والنصوص أو تدفقات الوقت الحقيقي.