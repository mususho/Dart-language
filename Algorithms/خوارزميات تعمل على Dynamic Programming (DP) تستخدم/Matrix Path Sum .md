# Matrix Path Sum

## ➕ Matrix Path Sum (مجموع مسار في مصفوفة)

---

## 🎯 الهدف:

> إعطاء مصفوفة 2D من الأعداد (مثل جدول أرقام)،
> 
> 
> نريد إيجاد **المجموع الأدنى** (أو الأعلى) لمسار من الخانة العلوية اليسرى `(0,0)` إلى الخانة السفلية اليمنى `(m-1, n-1)`،
> 
> مع القدرة على التحرك **إلى اليمين أو إلى الأسفل فقط**.
> 

---

### 📌 مثال مصفوفة:

```
csharp
نسختحرير
[
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]

```

المسار الأدنى مجموعًا:

`1 → 3 → 1 → 1 → 1` = 7

---

## 🧠 فكرة الحل (Dynamic Programming):

- ننشئ مصفوفة `dp` بحجم نفس مصفوفة الإدخال.
- كل خانة `dp[i][j]` تحتوي **أقل مجموع مسار** للوصول إلى `(i, j)`.
- القاعدة:
    - `dp[0][0] = grid[0][0]`
    - الحواف (الأول صف والعمود):
        - `dp[i][0] = dp[i-1][0] + grid[i][0]`
        - `dp[0][j] = dp[0][j-1] + grid[0][j]`
    - باقي الخانات:
        - `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`

---

## ✅ الكود الكامل في Dart:

```dart
dart
نسختحرير
int minPathSum(List<List<int>> grid) {
  int m = grid.length;
  int n = grid[0].length;

  List<List<int>> dp = List.generate(m, (_) => List.filled(n, 0));

  dp[0][0] = grid[0][0];

  // ملء الصف الأول
  for (int j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  // ملء العمود الأول
  for (int i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  // ملء باقي الخانات
  for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
      dp[i][j] = grid[i][j] + (dp[i - 1][j] < dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]);
    }
  }

  return dp[m - 1][n - 1];
}

```

---

## 🧪 تجربة:

```dart
dart
نسختحرير
void main() {
  List<List<int>> grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
  ];

  print("🛤️ أقل مجموع مسار = ${minPathSum(grid)}");
}

```

---

## ✅ الناتج المتوقع:

```
نسختحرير
🛤️ أقل مجموع مسار = 7

```

---

## 📦 التحليل:

| الخاصية | القيمة |
| --- | --- |
| الزمن | O(m * n) |
| الذاكرة | O(m * n) |
| النوع | Dynamic Programming |