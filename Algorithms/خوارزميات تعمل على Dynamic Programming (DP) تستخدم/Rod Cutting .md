# Rod Cutting

تمام! ننتقل الآن إلى خوارزمية كلاسيكية في البرمجة الديناميكية تسمى:

---

## ✂️ Rod Cutting

**(قطع القضيب - تعظيم الربح من قطع القضيب)**

---

## 🎯 الهدف:

> لديك قضيب طوله n وحدات،
> 
> 
> وقائمة أسعار `prices` حيث `prices[i]` هي سعر قطعة طولها `i+1`.
> 
> المطلوب: قطع القضيب إلى أجزاء (أو تركه كاملًا) بحيث تحقق **أقصى ربح ممكن**.
> 

---

## 🧠 الفكرة:

- نفكر بالقطع خطوة بخطوة، لكل طول `i` نحاول جميع القطع الممكنة `j` (من 1 إلى `i`) ونحسب الربح:
    
    ```
    lua
    نسختحرير
    dp[i] = max(dp[i], prices[j-1] + dp[i-j])
    
    ```
    
- `dp[i]` تمثل أقصى ربح لقضيب طوله `i`.

---

## ✅ الكود الكامل في Dart:

```dart
dart
نسختحرير
int rodCutting(List<int> prices, int n) {
  List<int> dp = List.filled(n + 1, 0);

  for (int i = 1; i <= n; i++) {
    int maxVal = 0;
    for (int j = 1; j <= i; j++) {
      maxVal = maxVal > (prices[j - 1] + dp[i - j]) ? maxVal : (prices[j - 1] + dp[i - j]);
    }
    dp[i] = maxVal;
  }

  return dp[n];
}

```

---

## 🧪 تجربة:

```dart
dart
نسختحرير
void main() {
  List<int> prices = [1, 5, 8, 9, 10, 17, 17, 20];
  int n = 8;

  print("✂️ أقصى ربح ممكن = ${rodCutting(prices, n)}");
}

```

---

## ✅ الناتج المتوقع:

```
نسختحرير
✂️ أقصى ربح ممكن = 22

```

---

## 📦 التحليل:

| الخاصية | القيمة |
| --- | --- |
| الزمن | O(n²) |
| الذاكرة | O(n) |
| النوع | Dynamic Programming |