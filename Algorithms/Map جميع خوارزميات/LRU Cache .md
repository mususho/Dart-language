# LRU Cache

## 🧠 ما هو الـ LRU Cache؟

> LRU تعني Least Recently Used – وهي طريقة لتخزين عدد محدود من البيانات (cache) بحيث يتم حذف أقل عنصر تم استخدامه مؤخرًا عندما يمتلئ الـ cache.
> 

### ✳️ الاستخدام:

- شائع في إدارة الذاكرة المؤقتة (مثل تخزين صور، نتائج عمليات، إلخ).
- عند إدخال عنصر جديد وكان الـ cache ممتلئًا، نقوم بإزالة العنصر **الأقدم استخدامًا**.

---

## 🎯 مواصفات الـ LRU Cache:

- يحتوي على حجم (capacity) ثابت.
- يوفر عمليتين رئيسيتين بكفاءة O(1):
    - `get(key)` → جلب القيمة
    - `put(key, value)` → وضع أو تحديث القيمة
- عندما يتم الوصول إلى عنصر أو إضافته، يصبح هو "الأحدث استخدامًا".
- عند تجاوز السعة، يتم إزالة "الأقدم استخدامًا".

---

## 🪜 خطوات بناء الـ LRU Cache:

### ✅ الخطوة 1: نحتاج إلى خريطة `Map` لتخزين العناصر بسرعة.

### ✅ الخطوة 2: نحتاج إلى `LinkedList` (أو قائمة) لتتبع ترتيب الاستخدام.

### ✅ الخطوة 3: عند `get` أو `put`:

- ننقل العنصر إلى نهاية القائمة لأنه "الأحدث استخدامًا".

### ✅ الخطوة 4: إذا تجاوزت السعة، نحذف أول عنصر (الأقدم).

---

## 📦 الكود الكامل مع الشرح:

```dart
dart
نسختحرير
import 'dart:collection';

/// ✅ الكلاس الرئيسي الذي يمثل الـ LRU Cache
class LRUCache<K, V> {
  // 🪜 الخطوة 1: تعريف السعة القصوى للـ Cache
  final int capacity;

  // 🪜 الخطوة 2: استخدام LinkedHashMap للحفاظ على ترتيب الإدخال
  // وهو يحافظ على الترتيب الذي نحتاجه تلقائيًا
  final _cache = LinkedHashMap<K, V>();

  // 🟢 الباني يستقبل السعة
  LRUCache(this.capacity);

  /// ✅ الدالة لجلب عنصر حسب المفتاح
  V? get(K key) {
    // إذا لم يكن المفتاح موجودًا، نرجع null
    if (!_cache.containsKey(key)) return null;

    // 🪜 الخطوة 3: تحديث الترتيب – إزالة العنصر ثم إعادته لجعله الأحدث
    V value = _cache.remove(key)!;
    _cache[key] = value;

    return value;
  }

  /// ✅ الدالة لإضافة أو تحديث عنصر
  void put(K key, V value) {
    // 🪜 الخطوة 4: إذا كان المفتاح موجودًا مسبقًا، نحذفه لتحديث الترتيب
    if (_cache.containsKey(key)) {
      _cache.remove(key);
    }

    // 🪜 الخطوة 5: إذا وصلنا السعة، نحذف أقدم عنصر (أول مفتاح)
    if (_cache.length >= capacity) {
      // استخدام iterator لإزالة العنصر الأول
      _cache.remove(_cache.keys.first);
    }

    // 🪜 الخطوة 6: إضافة العنصر كأحدث استخدامًا
    _cache[key] = value;
  }

  /// 🔍 دالة للمساعدة في طباعة محتويات الكاش (للتحقق)
  void printCache() {
    print('🔁 الحالة الحالية للـ Cache:');
    _cache.forEach((key, value) {
      print('🔸 $key: $value');
    });
    print('----------------------');
  }
}

```

---

## 🧪 مثال عملي للتنفيذ:

```dart
dart
نسختحرير
void main() {
  // 🟢 إنشاء Cache بسعة 3 عناصر
  LRUCache<int, String> cache = LRUCache(3);

  cache.put(1, "A"); // إدخال العنصر 1:A
  cache.put(2, "B"); // إدخال العنصر 2:B
  cache.put(3, "C"); // إدخال العنصر 3:C
  cache.printCache();

  // الآن الكاش ممتلئ، التالي سيحذف الأقدم (1:A)
  cache.put(4, "D");
  cache.printCache(); // يجب حذف 1:A

  // استخدام العنصر 2 (نجعله الأحدث)
  print("تم جلب العنصر 2: ${cache.get(2)}");
  cache.printCache();

  // إدخال عنصر جديد، سيحذف الأقدم وهو 3:C الآن
  cache.put(5, "E");
  cache.printCache();
}

```

---

## 🧾 المخرجات المتوقعة:

```
yaml
نسختحرير
🔁 الحالة الحالية للـ Cache:
🔸 1: A
🔸 2: B
🔸 3: C
----------------------
🔁 الحالة الحالية للـ Cache:
🔸 2: B
🔸 3: C
🔸 4: D
----------------------
تم جلب العنصر 2: B
🔁 الحالة الحالية للـ Cache:
🔸 3: C
🔸 4: D
🔸 2: B
----------------------
🔁 الحالة الحالية للـ Cache:
🔸 4: D
🔸 2: B
🔸 5: E
----------------------

```

---

## ✅ ملخص المزايا:

| الميزة | التوضيح |
| --- | --- |
| سرعة الوصول | `O(1)` باستخدام LinkedHashMap |
| الحفاظ على الترتيب | تلقائي بدون كود معقد |
| الكود نظيف وسهل التعديل | قابلية التوسيع لتخزين أي نوع بيانات |