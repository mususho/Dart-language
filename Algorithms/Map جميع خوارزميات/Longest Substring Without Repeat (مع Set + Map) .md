# Longest Substring Without Repeat (مع Set + Map)

## 🧠 ما هي المشكلة؟

> تُعطى سلسلة نصية (String) وتريد إيجاد أطول سلسلة فرعية (substring) متواصلة من الأحرف لا تحتوي على أحرف مكررة.
> 

---

### ✳️ مثال:

```dart
dart
نسختحرير
Input:  "abcabcbb"
Output: 3  // لأن "abc" أطول سلسلة بدون تكرار

Input:  "bbbbb"
Output: 1  // لأن "b" هو أقصى ما يمكن بدون تكرار

```

---

## 🪜 خطوات الحل باستخدام Set وMap (Sliding Window + Index Tracking)

### ✅ الخطوة 1: استخدم مؤشر بداية `start` ونهاية `end` لتمرير نافذة السلسلة

### ✅ الخطوة 2: استخدم `Map<char, index>` لتتبع آخر موقع ظهر فيه كل حرف

### ✅ الخطوة 3: إذا تكرّر حرف موجود بالفعل في النافذة:

- نُحدّث `start` إلى الموضع **الذي يلي** آخر تكرار له

### ✅ الخطوة 4: نحسب طول السلسلة الحالية، ونُحدث الحد الأقصى `maxLength`

---

## 📦 الكود الكامل مع شرح خطوة بخطوة:

```dart
dart
نسختحرير
// 🟢 نقطة الدخول الرئيسية
void main() {
  // سلسلة نصية لتجريب الخوارزمية
  String input = "abcabcbb";

  // استدعاء الدالة
  int result = lengthOfLongestSubstring(input);

  // عرض النتيجة
  print("🔍 أطول سلسلة بدون تكرار في \"$input\" هي: $result");
}

/// ✅ الدالة التي تنفذ الخوارزمية باستخدام Set و Map
int lengthOfLongestSubstring(String s) {
  // 🪜 الخطوة 1: التحقق من السلسلة الفارغة
  if (s.isEmpty) return 0;

  // 🪜 الخطوة 2: Map لتخزين آخر موقع لكل حرف ظهر
  Map<String, int> lastSeen = {};

  // 🪜 الخطوة 3: مؤشر بداية النافذة
  int start = 0;

  // 🪜 الخطوة 4: متغير لتخزين الحد الأقصى للطول
  int maxLength = 0;

  // 🪜 الخطوة 5: حلقة تمر على كل حرف باستخدام مؤشر end
  for (int end = 0; end < s.length; end++) {
    String currentChar = s[end];

    // ✅ إذا كان الحرف مكرر وداخل النافذة الحالية
    if (lastSeen.containsKey(currentChar) && lastSeen[currentChar]! >= start) {
      // 🪜 تحديث start ليبدأ بعد آخر موقع للحرف المكرر
      start = lastSeen[currentChar]! + 1;
    }

    // 🪜 تحديث موقع الحرف الحالي في الخريطة
    lastSeen[currentChar] = end;

    // 🪜 حساب طول السلسلة الحالية وتحديث الحد الأقصى
    int currentLength = end - start + 1;
    if (currentLength > maxLength) {
      maxLength = currentLength;
    }

    // ✍️ (يمكنك طباعة معلومات التتبع هنا لأغراض التصحيح)
    // print('نافذة: ${s.substring(start, end + 1)}, الطول الحالي: $currentLength');
  }

  // 🟢 إرجاع أقصى طول سلسلة بدون تكرار
  return maxLength;
}

```

---

## 🧪 مخرجات التجربة:

```bash
bash
نسختحرير
🔍 أطول سلسلة بدون تكرار في "abcabcbb" هي: 3

```

---

## 🔍 شرح خطوات التنفيذ عمليًا (للسلسلة: "abcabcbb")

| الحرف | start | end | الحالة | maxLength |
| --- | --- | --- | --- | --- |
| a | 0 | 0 | غير مكرر، نافذة = [a] | 1 |
| b | 0 | 1 | غير مكرر، نافذة = [ab] | 2 |
| c | 0 | 2 | غير مكرر، نافذة = [abc] | 3 |
| a | 0→1 | 3 | مكرر، start يتقدم بعد a القديمة | 3 |
| b | 1→2 | 4 | مكرر، start يتقدم بعد b القديمة | 3 |
| c | 2→3 | 5 | مكرر، start يتقدم بعد c القديمة | 3 |
| b | 3 | 6 | غير مكرر في النافذة، نافذة = [cb] | 3 |
| b | 3→7 | 7 | مكرر، start يصبح 7 | 3 |

---

## ✅ مزايا الحل:

| الميزة | التوضيح |
| --- | --- |
| الكفاءة | الزمن: O(n) لأننا نزور كل حرف مرة واحدة |
| البساطة | لا حاجة للتكرار داخل تكرار |
| التخزين الذكي | نستخدم `Map` لمعرفة آخر مرة ظهر فيها كل حرف |

---

## 💡 ملاحظات إضافية:

- لو استخدمنا `Set` فقط بدون معرفة **المواقع** فستكون الخوارزمية أقل كفاءة.
- هذا الحل مرن وسريع وقابل للتوسيع.

---

## 🎁 كود للتجريب مع مدخلات مختلفة:

```dart
dart
نسختحرير
void main() {
  List<String> testCases = [
    "abcabcbb", // 3
    "bbbbb",    // 1
    "pwwkew",   // 3 ("wke")
    "",         // 0
    " ",        // 1
    "dvdf"      // 3 ("vdf")
  ];

  for (var s in testCases) {
    print("🔍 \"$s\" → ${lengthOfLongestSubstring(s)}");
  }
}

```

---

## ✅ الخلاصة:

| الخطوة | الهدف |
| --- | --- |
| 1 | استخدم مؤشر بداية `start` |
| 2 | استخدم `Map` لتخزين موقع آخر تكرار |
| 3 | إذا تكرّر الحرف داخل النافذة، حرّك `start` للأمام |
| 4 | احسب الطول الأقصى لكل نافذة واحتفظ بالأكبر |

---