# Find Union

## 🧠 مقدمة: ما هي خوارزمية Find-Union؟

هي بنية بيانات تستخدم لتتبع مجموعة من العناصر المقسمة إلى مجموعات غير متقاطعة (Disjoint Sets). تُستخدم كثيرًا في مشاكل مثل:

- اكتشاف الدورات في الرسوم البيانية
- تتبع مكونات الاتصال (Connected Components)
- مشاكل التجميع (Grouping)

---

## 📦 العمليات الأساسية:

1. **Find**:
    - تُرجع المُمثل (الجذر) الخاص بالمجموعة التي ينتمي إليها عنصر معين.
    - تُستخدم لتحديد ما إذا كان عنصران ينتميان لنفس المجموعة.
2. **Union**:
    - تقوم بدمج مجموعتين غير متقاطعتين في مجموعة واحدة.

---

## ⚙️ تحسينات مهمة:

- **Path Compression** في عملية `find` لتقليل العمق.
- **Union by Rank/Size** لتقليل الارتفاع عند الدمج.

---

## ✅ خطوات بناء الخوارزمية في Dart:

1. إنشاء كلاس `DisjointSet`.
2. تهيئة الـ parent (الممثل لكل عنصر).
3. تهيئة الـ rank أو الحجم (اختياري للتحسين).
4. كتابة دالة `find()` مع ضغط المسار.
5. كتابة دالة `union()` مع مراعاة الرتبة/الحجم.

---

## 🧾 الكود الكامل والمشروح بلغة Dart:

```dart
dart
CopyEdit
// الخطوة 1: إنشاء الكلاس الرئيسي الذي يحتوي على بنية البيانات
class DisjointSet {
  // الخطوة 2: قائمة تمثل الأب (المُمثل) لكل عنصر
  List<int> parent;

  // الخطوة 3: قائمة تمثل الرتبة (العمق التقريبي) لكل عنصر - تُستخدم للتحسين
  List<int> rank;

  // الخطوة 4: المُنشئ (constructor) لتهيئة البنية لكل عنصر على حدة
  DisjointSet(int size) {
    parent = List<int>.generate(size, (index) => index); // كل عنصر أب لنفسه
    rank = List<int>.filled(size, 0); // الرتبة تبدأ من 0
  }

  // الخطوة 5: دالة find - لإيجاد ممثل (جذر) العنصر مع ضغط المسار
  int find(int x) {
    // إذا لم يكن الأب هو نفسه، نرجع للأب الأعلى (الجذر)
    if (parent[x] != x) {
      parent[x] = find(parent[x]); // ضغط المسار
    }
    return parent[x];
  }

  // الخطوة 6: دالة union - لدمج مجموعتين
  void union(int x, int y) {
    int rootX = find(x); // إيجاد الجذر الأول
    int rootY = find(y); // إيجاد الجذر الثاني

    // إذا كانا بالفعل في نفس المجموعة، لا حاجة للدمج
    if (rootX == rootY) return;

    // مقارنة الرتب ودمج حسب الرتبة الأصغر لتقليل العمق
    if (rank[rootX] < rank[rootY]) {
      parent[rootX] = rootY;
    } else if (rank[rootX] > rank[rootY]) {
      parent[rootY] = rootX;
    } else {
      // إذا كانت الرتب متساوية، اختر أيًا منهما وازيد رتبته
      parent[rootY] = rootX;
      rank[rootX]++;
    }
  }

  // خطوة إضافية: طباعة المجموعات الحالية (اختياري)
  void printSets() {
    for (int i = 0; i < parent.length; i++) {
      print('العنصر $i ينتمي للمجموعة ${find(i)}');
    }
  }
}

// مثال على الاستخدام:
void main() {
  // إنشاء 7 عناصر (0 إلى 6)
  DisjointSet ds = DisjointSet(7);

  // دمج بعض العناصر معًا
  ds.union(0, 1);
  ds.union(1, 2);
  ds.union(3, 4);
  ds.union(5, 6);
  ds.union(4, 5);

  // طباعة حالة المجموعات بعد الدمج
  ds.printSets();

  // اختبار: هل 0 و 2 في نفس المجموعة؟
  print('هل 0 و 2 في نفس المجموعة؟ ${ds.find(0) == ds.find(2)}');

  // اختبار: هل 2 و 3 في نفس المجموعة؟
  print('هل 2 و 3 في نفس المجموعة؟ ${ds.find(2) == ds.find(3)}');
}

```

---

## 🧪 الإخراج المتوقع:

```
arduino
CopyEdit
العنصر 0 ينتمي للمجموعة 0
العنصر 1 ينتمي للمجموعة 0
العنصر 2 ينتمي للمجموعة 0
العنصر 3 ينتمي للمجموعة 3
العنصر 4 ينتمي للمجموعة 3
العنصر 5 ينتمي للمجموعة 3
العنصر 6 ينتمي للمجموعة 3
هل 0 و 2 في نفس المجموعة؟ true
هل 2 و 3 في نفس المجموعة؟ false

```

---

## 📌 الخلاصة:

- **Find-Union** بنية قوية جدًا لحل مشاكل التقسيم والتحقق من الاتصال.
- باستخدام **Path Compression** و **Union by Rank** نحصل على أداء قريب من **O(1)** لكل عملية.
- Dart لغة مرنة ويمكن كتابة مثل هذه الخوارزميات فيها بسهولة.

---