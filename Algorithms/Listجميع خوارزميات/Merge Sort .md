# Merge Sort

## 🧠 ما هي خوارزمية Merge Sort؟

خوارزمية **Merge Sort** هي خوارزمية تعتمد على مبدأ **“التقسيم ثم الدمج” (Divide and Conquer)**.

- **الخطوة 1: تقسيم** القائمة إلى نصفين بشكل متكرر حتى تصل إلى أجزاء صغيرة جدًا (عناصر منفردة).
- **الخطوة 2: دمج** هذه الأجزاء الصغيرة بطريقة مرتبة.

---

## ✅ خطوات تصميم الخوارزمية:

| رقم | الخطوة |
| --- | --- |
| 1 | تعريف دالة `mergeSort` تأخذ قائمة وتعيد قائمة مرتبة. |
| 2 | إذا كان طول القائمة 1 أو أقل → تعتبر مرتبة بالفعل. |
| 3 | تقسيم القائمة إلى نصفين. |
| 4 | استدعاء الدالة نفسها على النصفين (Recursive calls). |
| 5 | دمج النصفين المرتبين باستخدام دالة `merge`. |
| 6 | إعادة النتيجة النهائية بعد الدمج. |

---

## 🧩 خطوات بناء دالة الدمج `merge`:

| رقم | الخطوة |
| --- | --- |
| 1 | إنشاء قائمة جديدة لتخزين النتيجة. |
| 2 | قارن العنصر الأول من كل قائمة فرعية وأضف الأصغر إلى النتيجة. |
| 3 | استمر حتى تنتهي إحدى القوائم. |
| 4 | أضف ما تبقى من العناصر (إن وجدت) من القائمة الأخرى. |

---

## 💻 الكود الكامل مع التعليقات والشرح المفصل:

```dart

// الخطوة 1: دالة رئيسية تقوم بفرز القائمة باستخدام Merge Sort
List<int> mergeSort(List<int> list) {
  // الخطوة 2: شرط التوقف - إذا كانت القائمة تحتوي على 0 أو 1 عنصر، فهي مرتبة مسبقًا
  if (list.length <= 1) {
    return list;
  }

  // الخطوة 3: إيجاد نقطة المنتصف لتقسيم القائمة إلى نصفين
  int mid = list.length ~/ 2;

  // تقسيم القائمة إلى نصفين: الأيسر والأيمن
  List<int> left = list.sublist(0, mid);
  List<int> right = list.sublist(mid);

  print("🪓 تقسيم القائمة: $list");
  print("↙️ يسار: $left");
  print("↘️ يمين: $right");

  // الخطوة 4: استدعاء Merge Sort بشكل متكرر على كل نصف (Recursion)
  left = mergeSort(left);
  right = mergeSort(right);

  // الخطوة 5: دمج النصفين المرتبين
  List<int> merged = merge(left, right);

  print("🔗 دمج $left و $right => $merged");

  // الخطوة 6: إعادة النتيجة النهائية بعد الدمج
  return merged;
}

// دالة المساعدة: دمج قائمتين مرتبتين في قائمة واحدة مرتبة
List<int> merge(List<int> left, List<int> right) {
  List<int> result = [];

  int i = 0; // مؤشر للقائمة اليسرى
  int j = 0; // مؤشر للقائمة اليمنى

  // الخطوة 2: المقارنة بين العناصر من كل قائمة
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.add(left[i]);
      i++;
    } else {
      result.add(right[j]);
      j++;
    }
  }

  // الخطوة 4: إضافة العناصر المتبقية (إن وجدت) من القائمتين
  while (i < left.length) {
    result.add(left[i]);
    i++;
  }

  while (j < right.length) {
    result.add(right[j]);
    j++;
  }

  return result;
}

// دالة main لتجربة Merge Sort
void main() {
  // قائمة غير مرتبة
  List<int> numbers = [38, 27, 43, 3, 9, 82, 10];

  print("🔢 القائمة قبل الترتيب:");
  print(numbers);

  // استدعاء Merge Sort
  List<int> sorted = mergeSort(numbers);

  print("✅ القائمة بعد الترتيب:");
  print(sorted);
}

```

---

## 🧪 مثال عملي:

إذا كانت القائمة `[38, 27, 43, 3]`

- التقسيم:
    - `[38, 27]` → `[38]`, `[27]` → دمج → `[27, 38]`
    - `[43, 3]` → `[43]`, `[3]` → دمج → `[3, 43]`
- دمج `[27, 38]` مع `[3, 43]` → `[3, 27, 38, 43]` ✅

---

## ⏱️ تحليل الأداء:

| الحالة | الزمن المستغرق (Time Complexity) |
| --- | --- |
| أفضل حالة | O(n log n) |
| أسوأ حالة | O(n log n) |
| متوسط الحالة | O(n log n) |
| استهلاك الذاكرة | O(n) ← بسبب القوائم الجديدة أثناء الدمج |

---

## 🧠 مميزات Merge Sort:

- فعال حتى للقوائم الكبيرة.
- **مستقر** (لا يغير ترتيب العناصر المتساوية).
- جيد للبيانات الكبيرة التي لا يمكن تحميلها كلها في الذاكرة (external sorting).