# Bipartite Graph

# ๐ง ูุง ูู ุงูุฑุณู ุงูุจูุงูู ุงูุซูุงุฆู (Bipartite Graph)ุ

> ุฑุณู ุจูุงูู ุซูุงุฆู ูู ุฑุณู ุจูุงูู ูููู ุชูุณูู ุนูุฏู ุฅูู ูุฌููุนุชูู ุจุญูุซ ูุง ุชูุฌุฏ ุญุงูุฉ ุชุฑุจุท ุนูุฏุชูู ูู ููุณ ุงููุฌููุนุฉ.
> 

> ุจุจุณุงุทุฉ: ูููู ุชูููู ูู ุนูุฏุฉ ุจุฃุญุฏ ููููู ููุท ุจุญูุซ ูุง ุชุชุตู ุนูุฏุชุงู ุจููุณ ุงูููู.
> 

---

# ๐ช ุฎุทูุงุช ุงูุชุญูู ุฅุฐุง ูุงู ุงูุฑุณู ุซูุงุฆู (ุจุงุณุชุฎุฏุงู BFS ุฃู DFS):

### โ ุงูุฎุทูุฉ 1: ูุณุชุฎุฏู ูุตูููุฉ ุฃู ุฎุฑูุทุฉ `color` ูุชุฎุฒูู ููู ูู ุนูุฏุฉ (0 ุฃู 1)

### โ ุงูุฎุทูุฉ 2: ูุจุฏุฃ ูู ุนูุฏุฉ ุบูุฑ ููููุฉุ ููุนุทููุง ููู (ูุซูุงู 0)

### โ ุงูุฎุทูุฉ 3: ูุฒูุฑ ุงูุฌูุฑุงูุ ูุนุทููู ุงูููู ุงููุนุงูุณ

### โ ุงูุฎุทูุฉ 4: ุฅุฐุง ูุฌุฏูุง ุฌุงุฑ ูู ููุณ ุงููููุ ูุงูุฑุณู ุบูุฑ ุซูุงุฆู

---

## ๐ฆ ููุฏ Dart ูุงูู ูุน ุดุฑุญ ูุชูุตูู:

```dart
dart
ูุณุฎุชุญุฑูุฑ
void main() {
  Map<int, List<int>> graph = {
    0: [1, 3],
    1: [0, 2],
    2: [1, 3],
    3: [0, 2],
  };

  bool result = isBipartite(graph);
  print("ูู ุงูุฑุณู ุซูุงุฆูุ $result");

  // ูุซุงู ุขุฎุฑ ุบูุฑ ุซูุงุฆู
  Map<int, List<int>> graph2 = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1],
  };

  print("ูู ุงูุฑุณู ุงูุซุงูู ุซูุงุฆูุ ${isBipartite(graph2)}");
}

/// ุฏุงูุฉ ููุญุต ุฅุฐุง ูุงู ุงูุฑุณู ุซูุงุฆู ุจุงุณุชุฎุฏุงู BFS
bool isBipartite(Map<int, List<int>> graph) {
  Map<int, int> color = {}; // ููู ูู ุนูุฏุฉ: 0 ุฃู 1

  for (int node in graph.keys) {
    if (!color.containsKey(node)) {
      if (!bfsCheck(node, graph, color)) {
        return false;
      }
    }
  }

  return true;
}

/// BFS ูุชูููู ุงูุนูุฏ ูุงูุชุญูู
bool bfsCheck(int start, Map<int, List<int>> graph, Map<int, int> color) {
  List<int> queue = [start];
  color[start] = 0;

  while (queue.isNotEmpty) {
    int node = queue.removeAt(0);
    int currentColor = color[node]!;

    for (int neighbor in graph[node] ?? []) {
      if (!color.containsKey(neighbor)) {
        color[neighbor] = 1 - currentColor; // ุงูููู ุงููุนุงูุณ
        queue.add(neighbor);
      } else if (color[neighbor] == currentColor) {
        // ูุฌุฏูุง ุฌุงุฑ ูู ููุณ ุงูููู => ุบูุฑ ุซูุงุฆู
        return false;
      }
    }
  }

  return true;
}

```

---

## ๐งช ูุฎุฑุฌุงุช ุงูุชุฌุฑุจุฉ:

```
arduino
ูุณุฎุชุญุฑูุฑ
ูู ุงูุฑุณู ุซูุงุฆูุ true
ูู ุงูุฑุณู ุงูุซุงูู ุซูุงุฆูุ false

```

---

## ๐ ุดุฑุญ ุชูุตููู:

| ุงูุฎุทูุฉ | ุงููุตู | ุงูููุฏ ุฃู ุงูุชุนููู |
| --- | --- | --- |
| 1 | ุชุนููู ููู ููุนูุฏุฉ ุงูุฃููู | `color[start] = 0` |
| 2 | ุฒูุงุฑุฉ ุงูุฌูุฑุงู ูุชูููููู ุจุงูููู ุงููุนุงูุณ | `color[neighbor] = 1 - currentColor` |
| 3 | ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ุฌูุฑุงู ุจููุณ ุงูููู | ุดุฑุท `color[neighbor] == currentColor` |
| 4 | ุชูุฑุงุฑ ุงูุฎุทูุงุช ููู ุนูุฏุฉ ุบูุฑ ููููุฉ | ูู ุงูุญููุฉ ุงูุฑุฆูุณูุฉ |

---

## ููุงุญุธุงุช:

- ุงูุฎูุงุฑุฒููุฉ ุชุนูู ุนูู ุงูุฑุณูู ุบูุฑ ุงูููุฌูุฉ.
- ูููู ุชุนุฏูู ุงูููุฏ ูุงุณุชุฎุฏุงู DFS ุจุฏู BFS ุญุณุจ ุงูุญุงุฌุฉ.
- ุชุณุชุฎุฏู ูู ุงูุชุญูู ูู ุฎุตุงุฆุต ุงูุฑุณููุ ุชูุณููุงุช ุงููุดุงููุ ูุฃูุนุงุจ ุงูุฃููุงู.