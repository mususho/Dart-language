# Quick Sort

## 🚀 ما هي خوارزمية Quick Sort؟

**Quick Sort** هي خوارزمية فعالة للترتيب، تعتمد على مبدأ **Divide and Conquer (التقسيم والتغلب)** مثل Merge Sort، لكنها غالبًا أسرع من merge في الممارسة.

---

## 📋 مبدأ العمل:

1. اختيار عنصر كمحور (pivot).
2. تقسيم العناصر إلى جزأين:
    - العناصر الأصغر من المحور.
    - العناصر الأكبر من المحور.
3. إعادة تطبيق الخوارزمية (Recursion) على كل جزء.
4. دمج الأجزاء مع المحور لإنتاج قائمة مرتبة.

---

## ✅ خطوات إنشاء Quick Sort:

| رقم | الخطوة |
| --- | --- |
| 1 | تعريف دالة `quickSort` تأخذ القائمة + فهرسي البداية والنهاية. |
| 2 | شرط التوقف: إذا كان `low < high`. |
| 3 | اختيار `pivot` وتحديد موقعه باستخدام دالة `partition`. |
| 4 | استدعاء `quickSort` على الجزأين (قبل وبعد المحور). |
| 5 | دالة `partition` تقوم بتحريك العناصر الأصغر من المحور يسارًا والأكبر يمينًا. |

---

## 💻 الكود الكامل مع الشرح داخل التعليقات:

```dart
dart
CopyEdit
// الخطوة 1: دالة quickSort الرئيسية - تستخدم recursion لترتيب القائمة
void quickSort(List<int> list, int low, int high) {
  // الخطوة 2: شرط التوقف - إذا كان هناك أكثر من عنصر في الجزء الحالي
  if (low < high) {
    // الخطوة 3: نحصل على فهرس التقسيم بعد ترتيب العناصر حول الـ pivot
    int pi = partition(list, low, high);

    print("🔄 تقسيم عند الفهرس $pi: ${list[pi]}");
    print("🔹 بعد التقسيم: $list");

    // الخطوة 4: استدعاء quickSort على الجزء الأيسر (قبل pivot)
    quickSort(list, low, pi - 1);

    // استدعاء quickSort على الجزء الأيمن (بعد pivot)
    quickSort(list, pi + 1, high);
  }
}

// الخطوة 5: دالة partition لترتيب العناصر حول pivot وإعادة موقعه
int partition(List<int> list, int low, int high) {
  // اختيار العنصر الأخير كـ pivot
  int pivot = list[high];
  int i = low - 1; // مؤشر لتحديد مكان أصغر عنصر

  print("📌 بدء partition من $low إلى $high (pivot = $pivot)");

  for (int j = low; j < high; j++) {
    // إذا كان العنصر الحالي أصغر أو يساوي pivot
    if (list[j] <= pivot) {
      i++; // تقدّم المؤشر
      // تبادل العناصر
      int temp = list[i];
      list[i] = list[j];
      list[j] = temp;

      print("↔️ تبديل ${list[i]} مع ${list[j]} → $list");
    }
  }

  // وضع الـ pivot في موقعه الصحيح في الوسط
  int temp = list[i + 1];
  list[i + 1] = list[high];
  list[high] = temp;

  print("✅ وضع pivot ${list[i + 1]} في الموضع ${i + 1}");

  return i + 1; // إرجاع موقع الـ pivot الجديد
}

// دالة main لتجربة الخوارزمية
void main() {
  // قائمة غير مرتبة
  List<int> numbers = [10, 7, 8, 9, 1, 5];

  print("🔢 القائمة قبل الترتيب:");
  print(numbers);

  // استدعاء quickSort على كامل القائمة
  quickSort(numbers, 0, numbers.length - 1);

  print("✅ القائمة بعد الترتيب:");
  print(numbers);
}

```

---

## 🧪 مثال عملي:

لو القائمة `[10, 7, 8, 9, 1, 5]`:

- نختار `5` كـ pivot
- نحرك كل ما هو أصغر من `5` إلى اليسار
- نضع `5` في موقعه الصحيح
- نكرر العملية على `[1]` و `[10, 7, 8, 9]` وهكذا

---

## ⏱️ تحليل الأداء:

| الحالة | الوقت (Time Complexity) |
| --- | --- |
| أفضل حالة | O(n log n) |
| متوسط الحالة | O(n log n) |
| أسوأ حالة | O(n²) ← عندما تكون البيانات مرتبة مسبقًا (بدون تحسين) |

---

## 🧠 مميزات Quick Sort:

- غالبًا أسرع من Merge Sort في الذاكرة المحلية.
- **لا تحتاج إلى ذاكرة إضافية كبيرة**.
- أداء ممتاز على البيانات العشوائية.

---

## ⚠️ ملاحظة:

النسخة الحالية من Quick Sort **تعدل القائمة نفسها (In-place)**.

---

##