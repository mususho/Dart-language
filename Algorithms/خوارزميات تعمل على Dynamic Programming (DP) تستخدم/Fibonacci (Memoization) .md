# Fibonacci (Memoization)

## 🧠 Fibonacci باستخدام Memoization

> الهدف: حساب العدد الـ n من تسلسل فيبوناتشي
> 
> 
> حيث:
> 

```
نسختحرير
fib(0) = 0
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2)

```

---

## ❌ بدون Memoization: بطيء جدًا (O(2^n))

لكن باستخدام **memoization**، نحفظ القيم المحسوبة في `Map<int, int>`.

---

## ✅ الكود الكامل مع شرح مفصل:

```dart
dart
نسختحرير
// خريطة لحفظ القيم المحسوبة مسبقًا
Map<int, int> memo = {};

int fibonacci(int n) {
  // 🟢 الحالة النهائية: أول رقمين
  if (n <= 1) return n;

  // 🔁 إذا كانت القيمة موجودة في الذاكرة، نرجعها
  if (memo.containsKey(n)) return memo[n]!;

  // 🧮 حساب القيمة لأول مرة وتخزينها
  memo[n] = fibonacci(n - 1) + fibonacci(n - 2);

  return memo[n]!;
}

```

---

## 🧪 تجربة الدالة:

```dart
dart
نسختحرير
void main() {
  int n = 40;

  print("🔢 Fibonacci of $n = ${fibonacci(n)}");
}

```

---

## ✅ الناتج المتوقع:

```
mathematica
نسختحرير
🔢 Fibonacci of 40 = 102334155

```

🔋 الفرق في السرعة كبير جدًا مقارنة بالـ recursion العادي!

---

## ⏱️ التحليل:

| الخاصية | القيمة |
| --- | --- |
| الزمن | O(n) |
| الذاكرة | O(n) لحفظ النتائج |
| قابلية التكرار | عالية جدًا |
| نوع التخزين | `Map<int, int>` |

---

## 🧠 ملاحظات:

- يمكن استخدام `List<int>` بدل `Map` إن كنت تضمن أن `n` ليس كبيرًا جدًا.
- يمكن تعديل الكود ليحسب عدد المرات التي استُخدمت فيها memoization لتتبّع الأداء.