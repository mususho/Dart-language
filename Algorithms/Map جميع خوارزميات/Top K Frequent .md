# Top K Frequent

## 🧠 ما هي المشكلة؟ (Top K Frequent Elements)

> تُعطى قائمة (List) من العناصر، ومطلوب منك إرجاع أكثر K عنصرًا تكرارًا في القائمة.
> 

---

### ✳️ مثال:

```dart
dart
نسختحرير
List = [1, 1, 1, 2, 2, 3]
K = 2
النتيجة: [1, 2] // لأن 1 ظهر 3 مرات، و2 ظهر مرتين

```

---

## 🪜 خطوات الحل:

### ✅ الخطوة 1: عدّ التكرارات باستخدام `Map`

- المفتاح (Key) = العنصر
- القيمة (Value) = عدد مرات التكرار

### ✅ الخطوة 2: تحويل التكرارات إلى قائمة من أزواج `(عنصر، عدد التكرار)`

### ✅ الخطوة 3: ترتيب القائمة تنازليًا حسب عدد التكرارات

### ✅ الخطوة 4: أخذ أول `K` عناصر من القائمة المرتبة

---

## 📦 الكود الكامل مع الشرح والتعليق:

```dart
dart
نسختحرير
// 🟢 نقطة البداية
void main() {
  // مثال على قائمة من الأعداد
  List<int> nums = [1, 1, 1, 2, 2, 3, 3, 3, 3];
  int k = 2;

  // استدعاء الدالة لطباعة أكثر K عنصر تكرارًا
  List<int> result = topKFrequent(nums, k);

  print("🎯 أكثر $k عناصر تكرارًا: $result");
}

/// ✅ دالة لإيجاد أكثر K عنصر تكرارًا في القائمة
List<int> topKFrequent(List<int> nums, int k) {
  // --------------------------
  // 🪜 الخطوة 1: إنشاء خريطة لحساب التكرارات
  Map<int, int> frequencyMap = {};

  for (int num in nums) {
    frequencyMap[num] = (frequencyMap[num] ?? 0) + 1;
  }

  // --------------------------
  // 🪜 الخطوة 2: تحويل التكرارات إلى قائمة من أزواج (العنصر، التكرار)
  List<MapEntry<int, int>> entries = frequencyMap.entries.toList();

  // --------------------------
  // 🪜 الخطوة 3: ترتيب القائمة حسب التكرار من الأعلى إلى الأقل
  entries.sort((a, b) => b.value.compareTo(a.value));

  // --------------------------
  // 🪜 الخطوة 4: استخراج أول K عناصر من القائمة المرتبة
  List<int> topK = [];

  for (int i = 0; i < k && i < entries.length; i++) {
    topK.add(entries[i].key);
  }

  // --------------------------
  // 🟢 النتيجة النهائية
  return topK;
}

```

---

## 🧪 مخرجات التجربة:

```bash
bash
نسختحرير
🎯 أكثر 2 عناصر تكرارًا: [3, 1]

```

> لأن 3 تكرر 4 مرات، و 1 تكرر 3 مرات.
> 

---

## 🔍 تفصيل الخطوات عمليًا:

| الرقم | الشرح | الكود |
| --- | --- | --- |
| 1 | نعدّ كم مرة ظهر كل عنصر | `frequencyMap[num] = (frequencyMap[num] ?? 0) + 1;` |
| 2 | نحول الخريطة إلى قائمة لسهولة الترتيب | `frequencyMap.entries.toList();` |
| 3 | نرتب القائمة حسب التكرار | `entries.sort((a, b) => b.value.compareTo(a.value));` |
| 4 | نأخذ أول `k` عناصر فقط | `topK.add(entries[i].key);` |

---

## ✅ الكود يعمل مع أي عدد عناصر وقيم K:

- إذا كانت القائمة طويلة مثل `[7, 7, 6, 6, 6, 5, 4, 4, 4, 4, 3]` و `k = 3`
    
    فستكون النتيجة `[4, 6, 7]` لأن:
    
    - 4 → 4 مرات
    - 6 → 3 مرات
    - 7 → 2 مرات

---

## 🚀 هل يمكن تحسين الكود؟ (Advanced)

إذا كنت تتعامل مع **بيانات ضخمة جدًا**:

- يمكن استخدام **Heap (أولوية)** بدلاً من الترتيب الكامل.
- ولكن في Dart، `PriorityQueue` غير مدعوم افتراضيًا إلا باستخدام مكتبة مثل `collection`.

---

## 🔁 نسخة تعمل مع أنواع أخرى (Generic):

```dart
dart
نسختحرير
List<T> topKFrequentGeneric<T>(List<T> items, int k) {
  Map<T, int> frequencyMap = {};
  for (var item in items) {
    frequencyMap[item] = (frequencyMap[item] ?? 0) + 1;
  }

  List<MapEntry<T, int>> entries = frequencyMap.entries.toList();
  entries.sort((a, b) => b.value.compareTo(a.value));

  return entries.take(k).map((e) => e.key).toList();
}

```

---

## 📌 ملخص:

| الخطوة | ماذا نفعل؟ |
| --- | --- |
| 1 | عدّ التكرارات في خريطة |
| 2 | تحويل الخريطة إلى قائمة أزواج |
| 3 | ترتيب حسب عدد التكرار |
| 4 | أخذ أول K عناصر |