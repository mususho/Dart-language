# Dynamic Programming (DP)

## ๐ง Dynamic Programming (ุงูุจุฑูุฌุฉ ุงูุฏููุงููููุฉ)

> Dynamic Programming (DP) ูู ุฃุณููุจ ูุญู ุงููุดููุงุช ุงูุชู ุชุญุชูู ุนูู ุญุงูุงุช ูุชูุฑุฑุฉ ููุฑุงุฑุงุช ุชุนุชูุฏ ุนูู ูุชุงุฆุฌ ุณุงุจูุฉุ ุจุทุฑููุฉ ุฃูุซุฑ ููุงุกุฉ ูู ุงูุชูุฑุงุฑ ุงูุนุงุฏู ุฃู ุงูุญู ุงูุนูุฏู (recursion).
> 

---

## โณ๏ธ ูุชู ูุณุชุฎุฏู DPุ

ุนูุฏูุง ุชุฌุฏ ูู ุงููุดููุฉ:

1. โ **Subproblems** โ ูุดููุฉ ูุจูุฑุฉ ูููู ุชูุณูููุง ุฅูู ูุดุงูู ูุฑุนูุฉ.
2. โ **Overlapping subproblems** โ ุงููุดุงูู ุงููุฑุนูุฉ ุชุชูุฑุฑ.
3. โ **Optimal substructure** โ ุงูุญู ุงูููุงุฆู ูุนุชูุฏ ุนูู ุงูุญููู ุงููุซูู ูููุดุงูู ุงูุฃุตุบุฑ.

---

## ๐ ุฃูุซูุฉ ูุดููุฑุฉ:

| ุงููุดููุฉ | ุงูุดุฑุญ |
| --- | --- |
| Fibonacci | ุงูุนุฏุฏ ุงูุชุงูู ูู ูุฌููุน ุงูุณุงุจููู. |
| Climbing Stairs | ูู ุทุฑููุฉ ูููุตูู ุฅูู ุงูุฏุฑุฌุฉ nุ |
| Knapsack | ุงุฎุชูุงุฑ ุงูุนูุงุตุฑ ุจุฃูุตู ูุงุฆุฏุฉ. |
| Coin Change | ุฃูู ุนุฏุฏ ุนููุงุช ูููุตูู ุฅูู ุงููุจูุบ. |
| Longest Common Subseq | ุฃุทูู ุณูุณูุฉ ูุดุชุฑูุฉ. |

---

## ๐งญ ุงุณุชุฑุงุชูุฌูุงุช ุงูุญู:

### 1. โ Top-Down (Memoization)

- ุญู ุจุงุณุชุฎุฏุงู recursion ูุน ุชุฎุฒูู ุงููุชุงุฆุฌ ุงูุณุงุจูุฉ.

### 2. โ Bottom-Up (Tabulation)

- ูุจูู ุงูุญู ุฎุทูุฉ ุจุฎุทูุฉ ูู ุงูุจุฏุงูุฉ ุจุฏูู recursion.

---

## โ ูุซุงู ุชุทุจููู ุจุณูุท: Fibonacci ุจุงุณุชุฎุฏุงู 3 ุทุฑู

### 1. ๐ ุงูุทุฑููุฉ ุงูุณุงุฐุฌุฉ (Recursion ููุท):

```dart
dart
ูุณุฎุชุญุฑูุฑ
int fibNaive(int n) {
  if (n <= 1) return n;
  return fibNaive(n - 1) + fibNaive(n - 2);
}

```

โ ุณูุฆุฉ ุฌุฏูุง ูู ุงูุฃุฏุงุก โ O(2^n)

---

### 2. โ Memoization (Top-Down):

```dart
dart
ูุณุฎุชุญุฑูุฑ
Map<int, int> memo = {};

int fibMemo(int n) {
  if (n <= 1) return n;
  if (memo.containsKey(n)) return memo[n]!;

  memo[n] = fibMemo(n - 1) + fibMemo(n - 2);
  return memo[n]!;
}

```

โ๏ธ ุฃูุถู ุจูุซูุฑ โ O(n) ุฒูู ู O(n) ุฐุงูุฑุฉ

---

### 3. โ Tabulation (Bottom-Up):

```dart
dart
ูุณุฎุชุญุฑูุฑ
int fibTab(int n) {
  if (n <= 1) return n;

  List<int> dp = List.filled(n + 1, 0);
  dp[1] = 1;

  for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

```

โ๏ธ ููุชุงุฒ โ O(n) ุฒูู ู O(n) ุฐุงูุฑุฉ

๐ก ูููู ุชุญุณูู ุงูุฐุงูุฑุฉ ุฅูู O(1) ุจุงุณุชุฎุฏุงู ูุชุบูุฑูู ููุท.

---

## ๐งช ุชุฌุฑุจุฉ ุฌููุน ุงูุทุฑู:

```dart
dart
ูุณุฎุชุญุฑูุฑ
void main() {
  int n = 10;

  print("๐ Naive Recursion: ${fibNaive(n)}");
  print("๐ง Memoization: ${fibMemo(n)}");
  print("โฌ๏ธ Tabulation: ${fibTab(n)}");
}

```

---

## โ ุงููุงุชุฌ:

```
yaml
ูุณุฎุชุญุฑูุฑ
๐ Naive Recursion: 55
๐ง Memoization: 55
โฌ๏ธ Tabulation: 55

```

---

## ๐ง ููุฎุต ููุงุฑูุฉ:

| ุงูุทุฑููุฉ | ุงูุฒูู | ุงูุฐุงูุฑุฉ | ุงูุฃุณููุจ |
| --- | --- | --- | --- |
| Naive Recursion | O(2^n) | O(n) | ุชูุฑุงุฑ |
| Memoization | O(n) | O(n) | ุฃุนูู ูุฃุณูู |
| Tabulation | O(n) | O(n) | ุฃุณูู ูุฃุนูู |

---

## ๐ ุฌุงูุฒ ูุชุทุจูู ุฃูููุ

ูู ุชุฑุบุจ ุฃู ููุชูู ุฅูู: